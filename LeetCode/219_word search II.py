# Leetcode 219. Word Search II
class TrieNode:
    
    def __init__(self, word_end = False):
        """
        Initialize a trie tree node.
        """
        self.word_end = word_end
        self.children = {}
        self.children_chars = set([])
    
    def add_word(self, word):
        if len(word) == 0:
            self.word_end = True # marks the end of a word
        else:
            head = word[0]
            if head not in self.children:
                self.children[head] = TrieNode() # add a trie node if it's a new character
                self.children_chars.add(head)
            
            self.children[head].add_word(word[1:]) # recursive add


class Solution(object):
    def findWords(self, board, words):
        """
        :type board: List[List[str]]
        :type words: List[str]
        :rtype: List[str]
        """
        if len(words) == 0:
            return []
        
        # Build the trie tree of words
        root = TrieNode()
        for word in words:
            root.add_word(word)
        
        # For each start position in the board,
        # DFS to form words until no more word can be generated by DFS. 
        # If a word could be in the trie tree, add it.
        m = len(board) # number of rows in the board
        if m == 0:
            return False
        n = len(board[0]) # number of columns in the board
        
        res = set([]) # use a set because could have multiple matches for a word
        for i in range(m):
            for j in range(n):
                path = [] # path used to store DFSed characters
                searched_pos = []
                self.generate_words(board, m, n, i, j, root, path, searched_pos, res)
        
        res = list(res)
        res.sort() # sorted
        return res
    
    def generate_words(self,board,m,n,i,j,node,path,searched_pos,res):
        """
        Generate all possible sequence of characters, starting at position (i,j)
        """
        char = board[i][j] # this position's character
        # If this char is in the node's trie trees, continue DFS
        if char in node.children_chars:
            path.append(char) # add this char to path
            searched_pos.append((i, j)) # add this position to searched_pos
            next_node = node.children[char] # next node to search on
            
            # If next_node is an end node, a word is found
            if next_node.word_end == True:
                res.add("".join(path))
            
            # next possible search positions
            next_positions = \
            [
                (max(i-1, 0), j),
                (min(i+1, m-1), j),
                (i, max(j-1, 0)),
                (i, min(j+1, n-1))
            ]
            for pos in next_positions:
                if pos not in searched_pos:
                    #print("Keep DFS. Chekcing pos {}, path is {}".format(pos, path))
                    self.generate_words(board,m,n,pos[0],pos[1],next_node,path,searched_pos,res)
            
            # Done searching this position, recover shared path and searched_pos 
            # for other DFS ways
            path.pop()  
            searched_pos.pop()
    